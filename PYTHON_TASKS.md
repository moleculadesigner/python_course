# Оглавление

- [Начало работы](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Начало-работы)
- [Числа](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Числа)
- [Возведение числа в степень](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Возведение-числа-в-степень)
- [Различные операции](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Различные-операции)
- [Ввод/Вывод](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#ВводВывод)
- [Переменные](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Переменные)
- [Циклы](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Циклы)
- [Условные операторы](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Условные-операторы)
- [Циклы Условные операторы](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Циклы--Условные-операторы)
- [Функции](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Функции)
  - [Области видимости переменных](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Области-видимости-переменных)
  - [Передача аргументов в функцию](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Передача-аргументов-в-функцию)
- [Списки и работа с ними (срезки генераторы)](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Списки-и-работа-с-ними-срезки-генераторы)
  - [Срезки (Slice)](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Срезки-slice)
  - [Кортежи](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Кортежи)
- [Строки](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Строки)
- [Словари](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Словари)
- [Задачи по биоинформатике](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Задачи-по-биоинформатике)
- [ООП](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#ООП)
  - [Классы](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Классы)
  - [Наследвование](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Наследование)
  - [Инкапсуляция](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Инкапсуляция)
  - [Полиморфизм](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Полиморфизм)
- [Исключения](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Исключения)
- [Финальное задание](https://github.com/skhayrulin/python_course/blob/master/PYTHON_TASKS.md#Финальное-задание)


# Начало работы

Интерпретатор Python после установки располагается, обычно, по пути /usr/local/bin/python3.1 или /usr/local/bin/python2.7. Для проверки наличия интерпритатора в системе можно воспользоваться системной утилитами `whereis` или `which` (это верно  относительно UNIX систем).
Откройте командную строку и наберите команду python
    
    $ python

При этом у вас должна интерпритатор откроется для в вас в интерактивном режиме например так:

```serg@sergpc:~$ python
Python 3.6.0 |Anaconda 4.3.1 (64-bit)| (default, Dec 23 2016, 12:22:00) 
[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> 

```

Теперь вы можете работать непосредственно с интеретатором вводя команды. Чтобы завершить работу интерактивной оболочки Pyhton можно нажать клавиши <kbd>Ctrl</kbd> + <kbd>D</kbd> или  <kbd>Ctrl</kbd> + <kbd>C</kbd> также можно воспользоваться командой `quit()`.

# Числа

Арифметические операции имеют ожидаемые приоритеты. При необходимости используются скобки.

1. Вычислить значение выражения 1 + 2\*3
2. Вычислить значение выражения (1 + 2)\*3
3. Вычислить значение выражения 1 + 2/3
4. Вычислить значение выражения 1 + 2/3 + 2
5. Вычислить значение выражения 1 + 2/(3 + 2)
6. Попробуйте разделить число на ноль, что выведется на экран

# Возведение числа в степень

Возведение целого числа в целую степень даёт целое число, если показатель степени  ≥0≥0 , и число с плавающей точкой, если он  < 0 < 0. Так что тип результата невозможно определить статически, если значение переменной n неизвестно.

6. Вычислить степень двойки разными способами (используйте встроенные функции пакета math pow и \*\* )
7. Вычислите степень 0.5 из отрицательного числа

# Различные операции

Операции приведение типов и вычисление остатков. 

1. Приведите целое число к числу с плавающей точкой (команда float(...))
2. Приведите число с плавающей точкой к целому (команда int(...))
3. Вычислите дробную часть числа
4. Вычислите остаток от деления (%)
5. Вычислите целое частное (//)
6. Как проверить, что число четное?

# Ввод/Вывод

В этом блоке рассматривается работа с функциями [print](https://docs.python.org/2/library/functions.html#print) и [input](https://docs.python.org/2/library/functions.html#input). Функция print обычно подается строка в качестве входной параметра строка передается в двойных "..." или одинарных '...'. Об остальных аргументах почитайте в документации или других источниках. Вам тоже могут пригодится некоторые строковые литералы 
`\n` - перевод строки на новую `\t` - табуляция.

1. Выведете строку приветствия с вашим именем (функция print(...))
2. Разработайте приложение принимающее на вход два числа и выводящее сумму этих чисел

# Переменные

Тип переменной в python определяется динамически информация о типе хранится в значение переменной, так, например, будет корректен следующий код

    x = 10      # здесь тип переменной int (целое число)
    x = 12.5    # теперь тип переменной стал float (число с плавающей точкой)
    x = "hello" # а теперь тип строковый str (строка или последовательность символов)
    x = True    # x теперь переменная булева типа принимает значение либо 0(False) либо 1(True)
    x = None    # пустая переменна слово None обозначает, что в переменной не хранится никакого значения

Как вы видели имя переменной не менялось и более того вы можете поверить, что это одна и тоже переменная, меняется только ее значение. Итак переменная задается следующим образом `var_name = value`. Переменная создается при ее инициализации. Можно комбинировать различные арифметические операции и присваивание например. Для удаления (очистки памяти занимаемой переменной) переменной и используйте функцию del.
    
    x += 10  # это эквивалентно x = x + 10
    x *= 10  # это эквивалентно x = x * 10
    x **= 10 # это эквивалентно x = x**10

1. Создайте целочисленную переменную и присвойте ей некоторое значение (например 123)
2. Создайте две переменные и присвойте значение первой второй ( операция равенства/присвоение = )
3. Создайте переменную как результат некоторой операции над числами (например 10 + 1)
4. Создайте переменную как результат некоторой операции над другими переменными (например var1 + var2)
5. Создайте переменную и удалите ее из контекста (операция del val)

# Циклы

Описываются следующими 2мя структурами.

    for cycle_var in  <iterable_object>:
        ...
    while <statment>:
        ...
В данном блоке могут быть полезны следующие функция `range(start, end, step)` подробнее [здесь](https://docs.python.org/2/library/functions.html#range). Функция `range(...)` создает объект который можно итерировать, первые два аргумента функции определяет интервал, третий аргумент определяет шаг т.е. каждый следующий объект получается из предыдущего следующим образом.
    
    next = prev + step
Чтобы прекратить выполнение цикла, не доходя до конца, можно воспользоваться ключевым словом `break` - при этом завершается ближайший цикл к слову `break`

    for i in range(1000):     # first loop
        for j in range(1000): # second loop
            print(j)
            break # завершится цикл  second loop
        print(i)
        break     # завершится цикл  first loop
        
В тоже время можно воспользоваться ключевым словом `continue` для продолжения работы цикла со следующей итерации
Пример:

    for i in range(1000):     # first loop
        print("Квадрат числа " + str(i**2))
        continue                            # при этом код следующий за словом continue не будет выполнятся
        print("куб числа " + str(i**3))
 
1. Выведите последовательность чисел 1..10 двумя различными типами цикла (while и for)
2. Выведите последовательность квадратов чисел от 1..100 различными типами цикла (while и for)
3. Выведите последовательность чисел от 112..133 в обратном порядке различными типами цикла (while и for)
4. Выведите последовательность Фибоначчи до 14ого числа
5. Выведете геометрическую последовательность до 15 числа (начиная с 1, шаг определяйте как хотите)
6. Посчитайте сумму предыдущей последовательности
7. Выведете матрицу некоторых числовых значений (на ваш выбор), двумя типами циклов (while, for)
8. Выведете некоторую диагональную матрицу
9. Выведете некоторую треугольную матрицу

# Условные операторы

Условные операторы представлены ключевыми словами:

* `if <expression>:` если, 
* `else:` тогда 
* `elif <expression>:` тогда если сокращенно <=> `else if`.

После описания условия оператор завершается двоеточием после чего идет код, выполняющийся в случае истинности условия. Обычно условные блоки записываются следующим образом

    if <expression>:
        x = 10
        x += 1
        print(x)
Что фактически означает, что если условие `<expression>` = True (истинно), то будет выполнятся код описанный в блоке `if`, а именно:

    x = 10
    x += 1
    print(x)
В случае ложности выражения `<expression>` = False (ложно) код описанный под условием не выполняется.Если вам необходимо разделить выполнение программы, тогда нужно использовать оператор `else` который тоже завершается двоеточием. Пример:

    if <expression>:
        x = 10
        x += 1
        print(x)
    else:
        x = 20
        x += 2
        print(x)
Т.е. если выражение `<expression>` = False (ложно), то выполняется код описанный в блоке `else`. Также можно использовать выражение `elif <expression>:`, которое по сути эквивалентно выражению `else if <expression>:`. Пример 
    
    n=4
    if n==1:
        print('один')
    elif n==2:
        print('два')
    elif n==3:
        print('три')
    else:
        print('много')

Для сравнения используются операторы 
* больше >
* меньше <
* равно ==
* не равно !=
* больше или равно >=
* меньше или равно <=

Логические выражения можно комбинировать с помощью `and`,`or`, `not` (эти операции имеют более низкий приоритет, чем сравнения). Если результат уже ясен из первого операнда, второй операнд не вычисляется. А вот так выглядит оператор if.

    if 1<2 and x<3:
        print('T')
    else:
        print('F')
        
Любопытная особенность питона: можно использовать привычные из математики сравнения вроде `xx<y` and `y<z`.

    1<2<=2 # эквивалентно 1<2 and 2<=2
    1<2<2  # эквивалентно 1<2 and 2<2

Есть и условные выражения:

    (0 if x<0 else 1)+1
Задачи:

1. Напишите условие проверяющее, что 200 больше 100 и меньше 300 двумя способами (с помощью and и or и как цепочку выражений)
2. Напишите условие проверяющей, что введено число больше 10 (число вводится при помощи команды input)
3. Напишите проверку на четность числа
4. Что будет результатом вычисления этого выражения `(0 if x<0 else 1)+1`, объясните почему
5. Коля купил N пирожков, а у Вани 100 пирожков напишите условие, проверяющее, что общее количество пирожков у ребят больше 100 и не больше 150 или больше 200 но меньше 300. Количество пирожков для Коли вводится из командной строки (input).
6. Предположим, что вы ввели число от 1..5 тогда напишите ряд условий проверяющий что это за число и выводящий его слово на английском или русском обозначающий это слово (например 1-one или один)
7. Выведете таблицы истинности для выражений `x and y` `x or y` `x and not y` `(x or z) and (y or z)`
8. Как может выглядеть вечный цикл
        
## Циклы + Условные операторы

1. Напишите проверку число на простату (число является простым, если оно делится нацело только на себя и единицу)
2. Выведете все простые числа для заданного интервала
3. Выведете все числа в заданном интервале, позиция которых четна/нечетна (режим работы должен определятся из некоторой переменной которая при значении True должны выводить числа стоящие на четной позиции и наоборот).
4. Запустите вечный цикл при этом на каждом шаге цикла просите ввести некоторое значение пользователя (команда input(...)), если пользователь ввел букву q то ваша программа должна завершаться
5. Найдите сумму всех четных элементов ряда Фибоначчи, которые не превышают четыре миллиона.
6. Найдите сумму всех чисел меньше 1000, кратных 3 или 5.
7. Найдите все тройки пифагора для заданного интервала


# Функции

Функция позволяет выносить некоторые части кода в отдельную сущность, которая может применятся к различным данным многократно. Это позволяет сделать код намного более практичными и эффективным, как с точки зрения выполнения, так и с точки зрения оптимизации и поддержки. В языке python функция определение функции предваряется ключевым словом `def` (defenition - определение on eng.) после через пробел идет имя функции, затем в круглых скобках перечисляются параметры или аргументы функции через запятую и наконец объявление функции заканчивается двоеточием после чего на новой строке и с новым отступом идет блок в котором описывается функция. Пример функция вычисляющая факториал числа (число передается в функцию через список аргументов):    
    
    def fac(n):
        r = 1
        for i in range(2, n + 1):
            r *= i
        return r
    
    if __name__ == '__main__':
        fac(10) # вызов функции для числа 10
Функция может возвращать результат своих вычислений или нет, зависит от вашей реализации. Так например функция `fac` возвращает результат как факториал числа, для того что бы функция вернула результат используйте ключевое слово `return`. Аргументы функции могут быть умолчательными т.е. если функция вызывается без определения аргумента, то функция запустится на выполнением с умолчательным значением аргумента. для определения умолчательных аргументов при перечисление аргументов функции нужно указать умолчательное значение конкретного аргумента `def my_funс(arg1, arg2, arg3=10):`. Пример:
    
    def my_pow(n, power=2):
        return r**power
    
    if __name__ == '__main__':
        my_pow(10)    # вызов функции для числа 10 значение аргумента power будет равно 2
        my_pow(10, 4) # вызов функции для числа 10 значение аргумента power будет равно 4
Также возможно запускать функцию внутри функции - рекурсивно.

    def my_func():
        my_func()
Будьте внимательны, так как вы можете получить вечный цикл (на самом деле он не будет вечным ).
Задачи:

1. Напишите функцию не принимающую никаких аргументов, выводящую приветствие с вашим именем
2. Напишите функцию принимающую один аргумент строка, выводящую эту строку
3. Напишите функцию возводящую число в квадрат, возвращающее полученное значение
4. Напишите функцию вычисляющую факториал числа, возвращающее полученное значение
5. Напишите функцию вычисляющую N-ое число последовательности Фибоначчи
6. Напишите функцию вычисляющую N-ое число арифметической последовательности, шаг последовательности должен передаваться дополнительным аргументов (по умолчанию этот аргумент должен быть равен 1)
7. Определите функцию вычисляющую площадь треугольника при этом в качестве параметров должны передаваться значение высоты и основания
8. Определите функцию, которая принимает значение коэффициентов квадратного уравнения и выводит значение корней или предупреждение, что уравнение не имеет корней (в случае если детерминант оказался отрицательным)
9. Напишите функцию, которая для заданного параметров интервала, выводит значение, некоторой математической функции (например: sin, cos ... для этого не забудьте подключить модуль math import math)
10. Напишите функцию, которая для заданного в аргументах списка, возвращает как результат перевернутый список
11. Перепешите функцию для вычисления чисел фибоначи в рекурсивной форме
12. Напишите функцию вычисляющую N-ое число арифметической последовательности в рекурсивной форме
13. Написать функцию XOR_cipher, принимающая 2 аргумента: строку, которую нужно зашифровать, и ключ шифрования,  которая возвращает строку, зашифрованную путем применения функции XOR (^) над символами строки с ключом.    Написать также функцию XOR_uncipher, которая по зашифрованной строке и ключу восстанавливает исходную строку.


## Области видимости переменных

В Python, переменные, на которые только ссылаются внутри функции, считаются глобальными. Если переменной присваивается новое значение где-либо в теле функции, считается, что она локальная, и, если вам нужно, то нужно явно указывать её глобальной.

    x = 10
    def bar():
        print(x)
    bar()
    
    x = 10
    def foobar():
        global x
        print(x)
        x += 1
    foobar()
    
Это явное объявление требуется для того, чтобы напомнить вам, что (в отличие от внешне аналогичной ситуации с переменными класса и экземпляра), вы на самом деле, изменяете значение переменной во внешней области видимости:
Вы можете сделать подобную вещь во вложенной области видимости использованием ключевого слова nonlocal:

    def foo():
        x = 10
        def bar():
           nonlocal x
           print(x)
           x += 1
        bar()
        print(x)
    foo()

## Передача аргументов в функцию

Если при вызове функции подставим в качестве значения аргумента переменную, а в теле функции мы меняем значение аргумента, то то, что произойдет, зависит от того, с каким значение связана наша переменная. Если переменная связана с неизменяемым значением, например int, str, tuple, то естественно, это значение не изменится. А вот если переменная связана со списком, словарем или классом, то значение связанного с переменной объекта изменится.


# Списки и работа с ними (срезки, генераторы)

Списки могут содержать объекты любых типов (в одном списке могут быть объекты разных типов). Списки индексируются с нуля. список создается при следующим образом

    x = [] # создали пустой список
    x = [100] # создали список с одним элементом 100

К списку применима операция индексации т.е. к каждому элементу списка можно обращаться по его соответствующему  номере в списке например:
    
    x = [1,2,3,4,5] # создали список из 5 элементов от 1 до 5
    print(x[0])
    print(x[4])
    
Результат:

    >>> 1
    >>> 5

Отрицательные индексы используются для счёта с конца: `s[-1]` - последний символ в списке, и т.д.Помимо индексации к список обладает рядом других функций с полным список можно познакомится в официальной [документации](https://docs.python.org/3/library/stdtypes.html#typesseq) краткий список операций 

Operation |	Result 
----------|----------------
s[i] = x | item i of s is replaced by x
s[i:j] = t | slice of s from i to j is replaced by the contents of the iterable t	 
del s[i:j] | same as s[i:j] = []	 
s[i:j:k] = t | the elements of s[i:j:k] are replaced by those of t	(1)
del s[i:j:k] | removes the elements of s[i:j:k] from the list	 
s.append(x) | appends x to the end of the sequence (same as s[len(s):len(s)] = [x])	 
s.clear() | removes all items from s (same as del s[:])	(5)
s.copy() | creates a shallow copy of s (same as s[:])	(5)
s.extend(t) or s += t | extends s with the contents of t (for the most part the same as s[len(s):len(s)] = t)	 
s *= n | updates s with its contents repeated n times	(6)
s.insert(i, x) | inserts x into s at the index given by i (same as s[i:i] = [x])	 
s.pop([i]) | retrieves the item at i and also removes it from s	(2)
s.remove(x) | remove the first item from s where s[i] == x	(3)
s.reverse() | reverses the items of s in place	(4)

Для перебора списка удобно использовать циклы
    
    x = [1,2,3]
    for i in x:
        print i

Результат
    
    >>> 1
    >>> 2
    >>> 3

Для того чтобы узнать длину списка удобно использовать встроенную функцию `len()` пример:
    
    x = [1,2,3]
    print(len(x))
    >>> 3
    
Если вы хотите проверить находится ли элемент в списке удобно использовать оператор `is`

    x = [1,2,3]
    1 in x
    >>>True

## Срезки (Slice)

Если вам необходимо выбрать какое-то подмножество списка, то удобно использовать срезки, которые позволяют извлекать подсписок списка. Синтаксис этого механизма выглядит следующим образом пример:
    
    x = [1,2,3,4,5,6]
    print(x[0:2])

Результат
    
    >>> [1,2]
    
Пример:

    x = [1,2,3,4,5,6]
    print(x[2:])
    print(x[:3])
    >>> [3,4,5,6]
    >>> [1,2,3]

Пример:
    x = [1,2,3]
    print(x[::-1])
    >>> [3,2,1]

Последний пример переворачивает список
   
    
## Генераторы

Можно строить список поэлементно.

    l=[]
    for i in range(10):
        l.append(i**2)
    print(l)
    
Но более компактно и элегантно такой список можно создать при помощи генератора списка (list comprehension). К тому же это эффективнее - размер списка известен заранее, и не нужно много раз увеличивать его. Опытные питон-программисты используют генераторы списков везде, где это возможно (и разумно).

    [i**2 for i in range(10)]
    [[i,j] for i in range(3) for j in range(2)]
    
В генераторе списков могут присутствовать некоторые дополнительные элементы, хотя они используются реже. Например, в список-результат можно включить не все элементы.

    [i**2 for i in range(10) if i!=5]
    
Создадим список случайных целых чисел.

    from random import randint
    l=[randint(0,9) for i in range(10)]
    print(l)

Функция sorted возвращает отсортированную копию списка. Метод sort сортирует список на месте. Им можно передать дополнительный параметр - функцию, указывающую, как сравнивать элементы.
    
    sorted(l)
    
    
## Кортежи 

Кортежи (tuples) очень похожи на списки, но являются неизменяемыми. Как мы видели, использование изменяемых объектов может приводить к неприятным сюрпризам.
Кортежи пишутся в круглых скобках. Если элементов  >1>1  или 0, это не вызывает проблем. Но как записать кортеж с одним элементом? Конструкция (x) абсолютно легальна в любом месте любого выражения, и означает просто x. Чтобы избежать неоднозначности, кортеж с одним элементом x записывается в виде (x,).

## Строки

Питон хорошо приспособлен для работы с текстовой информацией. В нём есть много операций для работы со строками, несколько способов записи строк (удобных в разных случаях). В современных версиях питона (3.x) строки юникодные, т.е. они могут содержать одновременно русские и греческие буквы, немецкие умляуты и китайские иероглифы.

### Задачи

1. Создайте список числовых значений от 0 до 100 (через циклы и генераторы)
2. Создайте список квадратов элементов предыдущего списка (через циклы и генераторы)
3. Создайте список, состоящий из четных элементов предыдущего списка (через циклы и генераторы)
4. Вот строка 'rewlkdfsklgjdflkjglkdsfjgkldfsjglkjeroitewuiotujdigjsdfklg;klsdfgkl;jsdfkl;gjldk;sfjgjlk;sdfjlk;gjsdfl;kgl;kdsfjgl;kjsdfl;kgjl;sdfkjg;lkjsdflbvjdfslkglkrewjhtiowerjutioerutopiytuilyhjdsfl;kghjl;sdkf;gjdffffffffflkgjlkdfjglkasjdfoitweigheripjgierglisjdfkjlghsdfkj;l;hgkljasdhfglk;hsdfkjlghlk;sdfhg;kljsdflkgjlk;sdfjgl;ksdfjl;kgjsdfl;kjglk;sdfjgkjsdfl;kgjs;dlkfjgoiw3eujtio34wuytiergoijherjhlgjsdflkjgkl;dfjgkl;sdfjkl;gjsdf;lkjg;lsjeriotuerl;kjdsfkl;jgh;lksdfjg;lksdfjg;lksdfkjg;lkjreopyulidsjfl;kghjs;ldkjg;lkkjr5l;h;kljyhkl;rirtiririiiiiiiiiiiiiierwtsj;kldfjg;lksdfjgl;ksdjfl;gj;lsdfjg;lk' - удалите из нее все повторяющиеся буквы и выведете строку уникальных букв
5. Как я буквенная подпоследовательность одинаковых символов самая длинная
6. Напишите функцию которая будет удалять заданную букву из строки и протестируйте ее на вышеприведенной строчке 
6. Вот список чисел - 2,3,3,45,4,23,43,54,34,5,32,423,4,23542354,3422,243,4,3,3,254,5643,3233,3,3,4,43,2,423,3,3,45,5,43,2,1,4,34234,34,3,342,23,4543,534,32423,23,4,4,4,3,423,3245,23,3,34254,235,234,5,235,4,345,235,23,5523,5,234,52,67,756,76,57,345,23,31,7,8,56,346,345,756,4343,754,674,8,568,9,65,34,3,5474,5687,56,2,3 - вычислите сумму этой последовательности
7. Найдите наибольший/наименьший элемент предыдущего списка
8. Отсортируйте предыдущий список
9. Напишите программу, которая спрашивает е пользователя как много чисел Фибоначчи нужно сгенерировать а затем генерирует их
10. сгенерируйте матрицу как список списков (через циклы и генераторы)
11. Напишите функцию транспонирования матрицы
12. Напишите функцию сложения матриц
13. Напишите функцию умножения матриц
14. Напишите функцию решения системы линейных уравнений методом Гаусса. Коэффициента уравнения задаются матрицей вектор неизвестных - вектором соответственно. [метод Гаусса и как его запрогать можно найти здесь](https://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%93%D0%B0%D1%83%D1%81%D1%81%D0%B0) (можно не делать если кажется слишком сложным)


## Множества

В соответствии с математическими обозначениями, множества пишутся в фигурных скобках. Элемент может содержаться в множестве только один раз. Порядок элементов в множестве не имеет значения, поэтому питон их сортирует. Элементы множества могут быть любых типов. Множества используются существенно реже, чем списки. Но иногда они бывают весьма полезны. Например, когда я собирался делать апгрейд системы на сервере, я написал на питоне программу, которая строила множество пакетов, установленных в системе до апгрейда; множество пакетов, имеющихся на инсталляционных CD; имеющихся на основных сайтах с дополнительными пакетами, и т.д. И она мне помогла восстановить функциональность после апгрейда. 
Чтобы создать множество из списка достаточно вызвать функцию [`set()`](https://docs.python.org/3/tutorial/datastructures.html#sets) которой в качестве аргуемнта подается итерируемй объект 
    
    x = [1,2,3,4,1,2,1,2]
    y = set(x)
    print(y)
    {1,2,3,4}
Как видно из примера в множестве останутся только уникальные объекты таким обазом set удобно использовать для построения уникальных последовательностей.


## Словари

Словарь содержит пары ключ - значение (их порядок несущественен). Это один из наиболее полезных и часто используемых типов данных в питоне.

    d={'one':1,'two':2,'three':3}

Можно узнать значение, соответствующее некоторому ключу. Словари реализованы как хэш-таблицы, так что поиск даже в больших словарях очень эффективен. В языках низкого уровня (например, C) для построения хэш-таблиц требуется использовать внешние библиотеки и писать заметное количество кода. В скриптовых языках (perl, python, php) они уже встроены в язык, и использовать их очень легко.

    print(d['two'])
    print(d['four'])
    ---------------------------------------------------------------------------
    KeyError                                  Traceback (most recent call last)
    <ipython-input-34-a0944cd0c15b> in <module>()
    ----> 1 d['four']

    KeyError: 'four'
Можно проверить есть ли ключ в словаре
    
    print('one' in d, 'four' in d)
    
Словарь может быть также задан при помощи генератора словаря:

    {a:a**2 for a in range(1, 10)}
    
Чтобы пробежаться по словарю можно таже использовать встроенную функцию `items()`, которая возвращает список кортежей (key, value). Также есть функции `keys()` и `values()`, который возвращают списки ключей и значений соответственно.

### Задачи:
1. Постройте список с повторяющимися значениями и создайте из него множество
2. Определите основные теоретико множественые операции, объединение, пересечение, разность двух множеств
3. Расширьте ваши функции для работы с бесконечно большим колличеством множеств.
4. Как можно просто в этой строке 'rewlkdfsklgjdflkjglkdsfjgkldfsjgliiiiiiiiiierwtsj;kldfjg;lksdfjgl;ksdjfl;gj;lsdfjg;lk' -  удалить все повторяющиеся эллементы
5. Предположим вы вводите строку, используя стандартную функцию input() посчитайте и вывидете какое колличество разных символов в этой строке
6. напишите функцию `concatenate(dict1, dict2)`, которая объединяет два словаря и вовращает результат, выведете результат

# Задачи по биоинформатике
## Задачи переехали [сюда](https://github.com/skhayrulin/python_course/blob/master/BIOINFORMATICS_TASKS.md)

# ООП
Питон является развитым объектно-ориентированным языком. Всё, с чем он работает, является объектами - целые числа, строки, словари, функции и т.д. Каждый объект принадлежит определённому типу (или классу, что одно и то же). Класс тоже является объектом. Классы наследуют друг от друга. Класс object является корнем дерева классов - каждый класс наследует от него прямо или через какие-то промежуточные классы.
    
    object,type(object)
    >>> (object, type)
    
Функция dir возвращает список атрибутов класса.

    dir(object)
    >>> ['__class__',
         '__delattr__',
         '__dir__',
         '__doc__',
         '__eq__',
         '__format__',
         '__ge__',
         '__getattribute__',
         '__gt__',
         '__hash__',
         '__init__',
         '__le__',
         '__lt__',
         '__ne__',
         '__new__',
         '__reduce__',
         '__reduce_ex__',
         '__repr__',
         '__setattr__',
         '__sizeof__',
         '__str__',
         '__subclasshook__']
Атрибуты, имена которых начинаются и кончаются двойным подчерком, используются интерпретатором для особых целей. Например, атрибут `__doc__` содержит док-строку.
    
    object.__doc__
    >>> 'The most base type'
    help(object)
    Help on class object in module builtins:

    class object
     |  The most base type
     
## Классы
Вот простейший класс. Поскольку не указано, от чего он наследует, он наследует от `object`.
    
    class MyClass:
        pass
Создать объект какого-то класса можно, вызвав имя класса как функцию (возможно, с какими-нибудь аргументами). Мы уже это видели: имена классов `int, str, list` и т.д. создают объекты этих классов.

    o=A()
    o,type(o)
    >>> (<__main__.A at 0x7f01f8124278>, __main__.A)
У только что созданного объекта o нет атрибутов. Их можно создавать (и удалять) налету.
    
    o.x=1
    o.y=2
    o.x,o.y
    >>> (1, 2)
    o.z
    >>> ---------------------------------------------------------------------------
        AttributeError                            Traceback (most recent call last)
        <ipython-input-10-c8c0d478b237> in <module>()
        ----> 1 o.z

        AttributeError: 'A' object has no attribute 'z'
    del o.y
    o.y
    >>>---------------------------------------------------------------------------
        AttributeError                            Traceback (most recent call last)
        <ipython-input-11-68acd6859c06> in <module>()
              1 del o.y
        ----> 2 o.y

        AttributeError: 'A' object has no attribute 'y'
Такой объект похож на словарь, ключами которого являются имена атрибутов: можно узнать значение атрибута, изменить его, добавить новый или удалить старый. Это и неудивительно: для реализации атрибутов объекта используется именно словарь.
    
    o.__dict__
    >>> {'x': 1}
Класс вводит пространство имён. В описании класса мы определяем его атрибуты (атрибуты, являющиеся функциями, называются методами). Потом эти атрибуты можно использовать как `Class.attribute`. Принято, чтобы имена классов начинались с заглавной буквы.
Вот более полный пример класса. В нём есть док-строка, метод `f`, статический атрибут `x` (атрибут класса, а не конкретного объекта) и статический метод getx (опять же принадлежащий классу, а не конкретному объекту).

    class S:
        'Простой класс'

        x=1

        def f(self):
            print(self)

        @staticmethod
        def getx():
            return S.x
Заклинание тёмной магии, начинающееся с `@`, называется декоратором. Запись

    @dec
    def fun(x):
        ...
эквивалентна

    def fun(x):
        ...
    fun=dec(fun)
То есть dec - это функция, параметр которой - функция, и он возвращает эту функцию, преобразованную некоторым образом. Мы не будем обсуждать, как самим сочинять такие заклинания - за этим обращайтесь в Дурмстранг. Функция `dir` возвращает список атрибутов класса. Чтобы не смотреть снова на атрибуты, унаследованные от object, мы их вычтем. Можно добавить и атрибут, являющийся функцией, т.е. метод. Сначала опишем (вне тела класса!) какую-нибудь функцию, а потом добавим её к классу в качестве нового метода.


    def g(self):
        print(self.y)
    S.g=g
    o.g()
    
Менять класс налету таким образом - плохая идея. Когда в каком-то месте программы Вы видете, что используется какой-то объект некоторого класса, первое, что Вы сделаете - это посмотрите определение этого класса. И если текущее его состояние отлично от его определения, это сильно затрудняет понимание программы.
Класс `S`, который мы рассмотрели в качестве примера - отнюдь не пример для подражания. В нормальном объектно-ориентированном подходе объект класса должен создаваться в допустимом (пригодном к использованию) состоянии, со всеми необходимыми атрибутами. В других языках за это твечает конструктор. В питоне аналогичную роль играет метод инициализации `__init__`. Вот пример такого класса.

## Наследование

    class C:

        def __init__(self,x):
            self.x=x

        def getx(self):
            return self.x

        def setx(self,x):
            self.x=x
            
Любой объектно-ориентированный язык, заслуживающий такого названия, поддерживает наследование. Класс `C2` наследует от `C`. Его объекты являются вполне законными для класса `C` (имеют атрибут x), но в добавок к этому имеют ещё и атрибут y. Метод `__init__` теперь должен иметь 2 параметра `x` и `y` (не считая обязательного `self`). К методам getx и setx, унаследованным от C, добавляются методы `gety` и `sety`. Чтобы инициализировать атрибут x, который был в родительском классе, мы могли бы, конечно, скопировать код из метода `__init__` класса `C`. В данном случае он столь прост, что это не преступление. Но, вообще говоря, копировать куски кода из одного места в другое категорически не рекомендуется. Допустим, в скопированном куске найден и исправлен баг. А в копии он остался. Поэтому для инициализации нового объекта, рассматриваемого как объект родительского класса `C`, нам следует вызвать метод `__init__` класса `C`, а после этого довавить инициализацию атрибута `y`, специфичного для дочернего класса `C2`. Первую часть задачи можно выполнить, вызвав `C.__init__(self,x)` (мы ведь только что написали строчку `class`, в которой указали, что класс-предок называется `C`). Но есть более универсальный метод, не требующий второй раз писать имя родительского класса. Функция super() возвращает текущий объект `self`, рассматриваемый как объект родительского класса `C`. Поэтому мы можем написать `super().__init__(x)`. Конечно, не только `__init__`, но и другие методы дочернего класса могут захотеть вызвать методы родительского класса. Для этого используется либо вызов через имя родительского класса, либо `super()`.

    class C2(C):

        def __init__(self,x,y):
            super().__init__(x)
            self.y=y

        def gety(self):
            return self.y

        def sety(self,y):
            self.y=y
    
    o=C2(1,2)
    o.getx(),o.gety()
    >>> (1,2)
o является объектом класса `C2`, а также его родительского класса `C` (и, конечно, класса object), но не является объектом класса `S`.

    isinstance(o,C2),isinstance(o,C),isinstance(o,object),isinstance(o,S)
    >>> (True, True, True, False)  
Эти функции используются редко. В питоне придерживаются принципа утиной типизации: если объект ходит, как утка, плавает, как утка, и крякает, как утка, значит, он утка. Пусть у нас есть класс Утка с методами иди, плыви и крякни. Конечно, можно создать подкласс Кряква, наследующий эти методы и что-то в них переопределяющий. Но можно написать класс Кряква с нуля, без всякой генетической связи с классом Утка, и реализовать эти методы. Тогда в любую программу, ожидающую получить объект класса Утка (и общающуюся с ним при помощи методов иди, плыви и крякни), можно вместо этого подставить объект класса Кряква, и программа будет по-прежнему работать. А функции `isinstance` и `issubclass` нарушают принцип утиной типизации. Класс может наследовать от нескольких классов. Мы не будем обсуждать множественное наследование, оно используется редко. Атрибут `__bases__` даёт кортеж родительских классов.

    C2.__bases__
    >>> (__main__.C,)
    C1.__bases__
    >>> (object,)
    
В питоне все методы являются, в терминах других языков, виртуальными. Пусть у нас есть класс `A`; метод `get` вызывает метод `str`.

    class A:

        def __init__(self,x):
            self.x=x

        def str(self):
            return str(self.x)

        def get(self):
            print(self.str())
            return self.x
Класс B наследует от него и переопределяет метод str.

    class B(A):

        def str(self):
            return 'The value of x is '+super().str()
## Инкапсуляция
Инкапсуляция является одним из ключевых понятий ООП. Все значения в Python являются объектами, инкапсулирующими код (методы) и данные и предоставляющими пользователям общедоступный интерфейс. Методы и данные объекта доступны через его атрибуты. Python предоставляет возмжность разработчику скрывать некторые особенности реализации, благодоря механизму сокрытия. Одиночное подчеркивание в начале имени атрибута говорит о том, что атрибут не предназначен для использования вне методов класса (или вне функций и классов модуля), однако, атрибут все-таки доступен по этому имени. Два подчеркивания в начале имени дают несколько большую защиту: атрибут перестает быть доступен по этому имени. Последнее используется достаточно редко. Есть существенное отличие между такими атрибутами и личными (private) членами класса в таких языках как C++ или Java: атрибут остается доступным, но под именем вида `_ИмяКласса__ИмяАтрибута`, а при каждом обращении Python будет модифицировать имя в зависимости от того, через экземпляр какого класса происходит обращение к атрибуту. Таким образом, родительский и дочерний классы могут иметь атрибут с именем, например, «`__f`», но не будут мешать друг другу.

    class parent(object):
        def __init__(self):
          self.__f = 2
        def get(self):
          return self.__f
    ....
    class child(parent):
        def __init__(self):
            self.__f = 1
            parent.__init__(self)
        def cget(self):
            return self.__f
    ....
    >>> c = child()
    >>> c.get()
    2
    >>> c.cget()
    1
    >>> c.__dict__
    {'_child__f': 1, '_parent__f': 2}  # на самом деле у объекта "с" два разных атрибута
Особым случаем является наличие двух подчеркиваний в начале и в конце имени атрибута. Они используются для специальных свойств и функций класса (например, для перегрузки операции). Такие атрибуты доступны по своему имени, но их использование зарезервировано для специальных атрибутов, изменяющих поведение объекта.

    In [21]: class aa:
        ...:     def __str__(self):
        ...:         return "Hello"
    In [22]: bb = aa()
    In [23]: print(bb)
    Hello
## Полиморфизм
В компилируемых языках программирования полиморфизм достигается за счёт создания виртуальных методов, которые в отличие от невиртуальных можно перегрузить в потомке. В Python все методы являются виртуальными, что является естественным следствием разрешения доступа на этапе исполнения. (Следует отметить, что создание невиртуальных методов в компилируемых языках связано с меньшими накладными расходами на их поддержку и вызов).

    In [24]: class Animal:
        ...:     def run(self):
        ...:         print('Run like Animal')
    In [25]: class Cat(Animal):
        ...:     def run(self):
        ...:         print('Run Like Cat')
    In [26]: c = Cat()
    In [27]: c.run()
    Run Like Cat
    In [28]: animanl = Animal()
    In [29]: animanl.run()
    Run like Animal
Явно указав имя класса, можно обратиться к методу родителя (как впрочем и любого другого объекта). В общем случае для получения класса-предка применяется функция super.

    In [33]: class Cat(Animal):
    ...:     def run(self):
    ...:         super(Cat,self).run()
    ...:         print('Run Like Cat')
    In [34]: c =Cat()
    In [35]: c.run()
    Run like Animal
    Run Like Cat

# Исключения
Всякие недопустимые операции типа деления на 0 или открытия несуществующего файла приводят к возбуждению исключений. Интерпретатор питон печатает подробную и понятную информацию об исключении. Если это интерактивный интерпретатор, то сессия продолжается; исли это программа, то её выполнение прекращается. В питоне отладчик приходится использовать гораздо реже, чем в более низкоуровневых языках, потому что эти сообщения интерпретатора позволяют сразу понять, где и что неверно. Впрочем, иногда приходится использовать и отладчик. Допустим, из сообщения об ошибке Вы поняли, что некоторая функция вызвана со строковым аргументом, а Вы про него думали, что он число. 

    In [36]: 1/0
    ---------------------------------------------------------------------------
    ZeroDivisionError                         Traceback (most recent call last)
    <ipython-input-36-05c9758a9c21> in <module>()
    ----> 1 1/0

    ZeroDivisionError: division by zero
Исключения можно отлавливать, и в случае, если они произошли, выполнять какой-нибудь корректирующий код.

    In [42]: try:
        ...:     x = 1/0
        ...: except ZeroDivisionError as e:
        ...:     print(e)    
    division by zero
    In [45]: try:
        ...:     x=1/0
        ...: except ZeroDivisionError as e:
        ...:     x = 0  
    In [46]: x
    Out[46]: 0
Если в Вашем коде возникла недопустимая ситуация, нужно возбудить исключение оператором `raise`.
    
    In [49]: try:
        ...:     if y == 0:
        ...:         raise ZeroDivisionError("You're trying divide by zero")
        ...:     x=1/y
        ...: except ZeroDivisionError as e:
        ...:     print(e)   
    You're trying divide by zero
В Python имеетсся масса уже встренных исключений таких как `ZeroDivisionError`, `IOError` и так далее полный сипсок можно найи [здесь](https://docs.python.org/3/library/exceptions.html). Тем не мение у вас есть возможность создавать свои собственные типы исключений, так и следует поступать чтобы ваши ошибки не путались с встроенными сиключениями. Для этого необходимо создать ваш тип исключений, которой наследуется от класса встроенного `Exception`:

    In [51]: class MyException(Exception):
        ...:     def __str__(self):
        ...:         return "HaHa you're on the wrong way"
    In [52]: try:
        ...:     raise MyException()
        ...: except MyException as e:
        ...:     print(e)
        ...:     
    HaHa you're on the wrong way

Кроме того конечно же ваш код может генерировать неколько типов исключений. В таком случае нужно писать неколько блоков обработчиков исключений при этом при выбрасывание исключений будет выбран наиболее подходящий блок обработки:

    In [62]: def f(y):
        ...:     if y == 0:
        ...:         raise ZeroDivisionError("Y is equal to 0")
        ...:     return 1/y
    In [63]: class SQRTError(Exception):
        ...:     def __str__(self):
        ...:         return "Check you're input case we're not working with complex number"
    In [66]: from math import sqrt
    In [67]: def my_sqrt(n):
        ...:     if n < 0:
        ...:         raise SQRTError()
        ...:     return sqrt(n)
    In [72]: try:
        ...:     f(0)
        ...:     my_sqrt(-1)
        ...: except ZeroDivisionError as e:
        ...:     print(e)
        ...: except SQRTError as e:
        ...:     print(e)
        ...:     
        ...:     
    Y is equal to 0

    In [73]: try:
        ...:     f(10)
        ...:     my_sqrt(-1)
        ...: except ZeroDivisionError as e:
        ...:     print(e)
        ...: except SQRTError as e:
        ...:     print(e)     
    Check you're input case we're not working with complex number


# Финальное задание
Напишите программу "калькулятор". Программа должна быть способной обрабатывать арифметические выражения и выводить результат,
например (ввод):

    1 + 2
    >>> 3
    
Также программа должна быть способна сохранять переменые, например (ввод):
    
    x=2*(4+2)
    >>> x = 12

После ввода новых переменных калькулятор должен быть способен работать с этими переменными, пример:
    
    y = 12
    x = 10
    z = x * y
    z
    >>> 120
Калькулятор должен быть способен создавать функции. Определяться они должны следующим образом: сначала идет зарезервированное слово `function`, затем имя функции, после чего в скобках через запятую перечисляются аргументы и, после закрывающей скобки и двоеточия, идет определение функции как одного арифметического выражения, пример:
    
    function pow2(x): x*x
После этого заявленная функция должна быть доступна, т.е.:
    
    pow2(3)
    >>> 9
Также должна быть возможность посмотреть все созданные переменные в контексте программы, например, с помощью зарезервированного слова `print` - выводит список всех переменных и функций в программе:
    
    print
    >>> x - переменная
        y - переменная
        z - переменная
        pow2 - функция

Если пользователь ввел слово `quit`, программа должна завершать свое выполнение. Если переменная или функция еще не определена, то должно выводиться сообщение, что мы пытаемся использовать еще не определенную переменную или функцию. Такое же поведение должно быть при неверном арифметическом выражении, например, при делении на ноль.
